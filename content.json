{"pages":[{"title":"About me","text":"","link":"/about/me.html"}],"posts":[{"title":"first hexo page","text":"第一篇md博客，大标题 很棒哦 very Good Excellent!就看撒 激发了的萨芬就 如葡萄糖 skfjlasjflljfdslf","link":"/2021/09/08/first-hexo-page/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/09/08/hello-world/"},{"title":"使用hexo + github打造你的个性化博客","text":"建造自己的个人博客是很多新手小伙伴的梦想，今天为大家带来手把手教程，而且是免费的，甚至不需要申请域名，不需要购买虚拟主机。 大家可以先看下我的博客http://www.relaxman.cn/ 下面我从四个方面来带大家操作。1. 使用github创建自己的github page 首先要有github账户，如何注册和使用github，我不再过多介绍。我重点介绍如何创建github page来免费托管我们的静态网站。 如上图，新建github repo，在Repository name中填写你的 username.github.io 这个格式是固定的，这是每个账号专属的 page,点击创建。恭喜你！！你现在有了新的代码仓，你可以尝试向该仓库提交一个简单的index.html. 然后在浏览器通过 你的username.github.io 来访问，看你页面是否生效。 现在有了github为我们托管代码，并免费给了我们一个域名来访问。下面我们开始生成我们的博客，并将其托管到github上。 2. 了解和使用hexo创建个性化博客 hexo官网, Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。，有众多免费主题供选用，可以一键部署。 如何使用？首先你需要Node环境，请自行安装最新node.js 全局安装hexo 1npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，创建hexo项目,并自动安装相关依赖模块。 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install blog的基础配置在_config.yml中可以配置。 title配置博客的标题，对应Html中的title,细节不再介绍，重点是配置github的page repo地址 下面介绍几个常用命令 12345hexo new blogName # 用于创建新的博客文章hexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo generate # 简写形式hexo g 用于生成静态文件hexo server # 简写hexo s 启动本地服务器，用于预览网站效果hexo deploy # 简写hexo d 一键部署，将静态资源上传到git仓，并完成网站部署 3. 了解和使用icarus主题，美化自己的博客 更改博客默认主题：主题列表，具体使用方法参照列表中每个主题的具体说明，方式基本是一样的，首先安装一些模块，或者将主题clone到本地的themes下,手动配置_config.yml中的theme为你选择的主题名，或者通过命令自动配置。 4. 使用个性化域名 在腾讯云或者阿里云等云厂商购买域名，新用户一般8元左右，可以用一年。 有了域名后要先实名认证，通常不超过一天可以认证完成。（github 上面的博客空间属于国外空间，绑定域名不用备案） 解析域名规则 为自己的github page添加绑定规则详细步骤参考：github page 绑定新域名","link":"/2021/09/12/hexoBlogTutorial/"},{"title":"近两年的工作感想","text":"一个月后我将从某大公司离职 学到了什么 代码的规范性制定和遵守编码规范，有利于代码的开发和维护。从开发人员的角度，养成良好的编码习惯。从集体的角度看，代码整洁规范会提高了代码的可读性和可维护性。这一点看似简单，其实很多大公司都难以完全做到，开发人员水平参差不齐，难以把控。这就需要岗前培训，工具自动化审核。 代码审核（Code Review)每个项目的代码仓要有相应的负责人，对仓库的所有合入进行把控，审核后方可合入。 对实验结果做好记录，用可视化的表格等方式呈现结果。即能方便自己理清思路，又能更好的展示结果。 开发人员自测 开发人员的基本素质，对每次提交的代码做到自测无误，放可提交入库。 工欲善其事必先利其器（强大的辅助工具）善于使用和开发辅助工具，让工作更高效更简单。 终身学习，始终保持对学习的热情和渴望，利用好下班之后的时间提高自己的技术能力。 成为T形人才，涉略广泛，专业深入。 未来之路 回到一家小公司，担任部门经理。重新干老本行。看似回到过去，但又是新的起点。要以新的视角，新的态度，将工作当成奋斗的事业。 技术和业务的结合。 培养新人 深度思考，多与人交流。","link":"/2021/09/26/%E8%BF%91%E4%B8%A4%E5%B9%B4%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%83%B3/"},{"title":"c# 函数参数 按值传递及按引用传递","text":"C#中的数据类型分两大类:值类型和引用类型. 值类型:直接存储数据的值,保存在内存中的线程栈中（stack） 引用类型:存储的是值的引用（是一个内存地址）在线程栈上,而实际值保存在托管堆(heap)中，即引用类型的保存分成两块，线程栈，内存堆。 当使用引用类型时先找到stack中的地址,通过该地址可以获取heap中的实际值. 类似下图： C#预定义的简单类型,像int,float,bool,char都是值类型，另外enum(枚举),struct(结构)也是值类型 string,数组,自定义的class就都是引用类型了.其中的string是比较特殊的引用类型.C#给它增加个字符恒定的特性. C# 函数的参数 如果不加ref,out这样的修饰符显式申明参数是通过引用传递外,默认都是值传递. 这里要注意的一个问题是,参数的类型是值类型还是引用类型和传参数时用值传递还是引用传递是两个不同的概念. 假如有void FunTest(int [] array) 和void FunTest(int a)这两个函数.参数array是引用类型,a是值类型.但是他们传递时都是按值传递. 我们来举个例子说明下, 按值传递参数: 12345678910111213141516171819202122232425262728 class Program { public static void ChangeInt(int num) { num = 123; } public static void ChangeArray(int[] array) { array[0] = 10; array = new int[] { 6, 7, 8, 9 }; } static void Main(string[] args) { int anum = 1; int[] aarray = { 1, 2, 3 }; ChangeInt(anum); ChangeArray(aarray); Console.WriteLine(&quot;value of num: &quot; + anum); Console.Write(&quot;value of aarray: &quot;); foreach (int i in aarray) Console.Write(i + &quot; &quot;); } } 结果是:value of anum : 1 value of aarray :10 2 3 可能看到结果会有点奇怪.我们一般认为值传递就是把值拷贝一份,然后不管在函数中对传入的参数做啥改变,参数之前的值不会受啥影响,所以anum没有变成123,仍然是1 但是aarray[0]为啥却变成10了呢? 前面我们有说到引用类型在内存中是保存为两个部分,一个是stack中的内存地址,另一个是heap中的实际值.用时我们只直接用stack中的值,我们假如stack中的值为0xabcdefgh,就说是aaraay指向它吧. 那么我们按值传递时就是把这个stack的值拷贝成另一份就假如是array指向它吧.跟拷贝anum的值1一样. 但是我们操作内存地址这样的值时不会像整数一样直接操作它,而只会通过它去找heap中的实际值. 于是我们array[0] = 10.改变了实际上还是heap中数组的值了. 但array = new int []{6,7,8,9}没有对之前传的aarray产生影响.这个操作的意义是在heap中重新开辟一块内存,保存着值6,7,8,9.这这块内存的地址赋给array,于是它之前的值0xabcdefgh被改写了.但aarray指的值stack值仍没变,仍是0xabcdefgh 按引用传递参数 可以用out或ref显式指定.它们大部分时候可以通用,只是有一点细小区别. 先用ref 来举例吧,还用上面的例子,只是加个了关键字ref 123456789101112131415161718192021222324252627class Program{ public static void ChangeInt(ref int num) { num = 123; } public static void ChangeArray(ref int[] array) { array[0] = 10; array = new int[] { 6, 7, 8, 9 }; } static void Main(string[] args) { int anum = 1; int[] aarray = { 1, 2, 3 }; ChangeInt(ref anum); ChangeArray(ref aarray); Console.WriteLine(&quot;value of num: &quot; + anum); Console.Write(&quot;value of aarray: &quot;); foreach (int i in aarray) Console.Write(i + &quot; &quot;); }} 结果是: value of anum : 123 value of aarray :6 7 8 9 跟按值传递的结果完全不同吧 num = 123我们是容易理解.我们再来说下aarray的值为啥变了吧 按引用传递时aarray指向的stack中的值不会复制一份,而是直接传过去.这样array[0]= 10这样赋值时也同样改变了heap中 1 2 3的值,变为10 2 3,如果 没有array = new int [] {6,7,8,9}这个语句,则它的结果跟上面按值传递是完全一样的.但有个这句话后就不一样,我们知道上面说了它的含义,在heap中开辟一块新内存 值是6 7 8 9,而aarray指向的stack的值被改写了,改为指向保存6 7 8 9的内存地址了.那含有10 23的那一块内存其实还继续存在,只是没有谁引用到它了.到时垃圾回收器会把它回收的. 补充: 说下out 和ref的细小区别 ref 传进来的参数必须要先赋值. 像上面 的例子中如果这样写 123 int num; ChangeInt(ref int num); //报错 就会出错,必须先给num给个值1. 而且out传进来的参数可以不先赋值. 12 out num; ChangeInt(out int num);是对的 另外还有个区别就是如果用out的时候ChangeInt函数中必须有某个地方给num赋值了,而用ref不一定需要在函数中给num赋值 其实这样做的目的很好理解.C#为了确保在任何情况下num必须有个值,不能为空. 因为用ref,在调用函数前必须保证参数有值,所以在函数中就不必要求它一定再赋值 而用out由于在调用函数前不用保证参数必须有值,所以在函数中必须保证给它个值 ChangeInt(ref int num)和ChangeInt(out int num)虽然不一样,但是不能共存,不能当作两个不同的函数 而ChangeInt(int num)和上面 的两个函数是完全不一样的,可以放到一起共存 这样的话调用的时候ref ,out这样的关键字不能省的.必须匹配","link":"/2021/10/31/method-param-md/"}],"tags":[{"name":"first blog","slug":"first-blog","link":"/tags/first-blog/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"c#","slug":"c","link":"/tags/c/"}],"categories":[{"name":"tutorial","slug":"tutorial","link":"/categories/tutorial/"},{"name":"experiment","slug":"tutorial/experiment","link":"/categories/tutorial/experiment/"}]}